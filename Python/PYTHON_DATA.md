PYTHON_DATA
### Data structure

> 자료 구조
> 
- 데이터를 효율적으로 저장하고 관리할 수 있도록 설계된 structure

### 메서드

- 객체에 속한 함수
- 객체의 상태를 조작하거나 동작을 수행
- 데이터 타입 객체.메서드() 형태로 사용

> 매직 메서드
> 
- “__메서드()”
- 자동적으로 동작하는 메서드

### 시퀀스 데이터 구조

> 문자열 조회 / 탐색 및 검증 메서드
> 

| s.find(x) | x의 첫 번째 위치를 반환. 없으면 -1 반환 |
| --- | --- |
| s.index(x) | x의 첫 번째 위치를 반환. 없으면 오류 발생 |
| s.isalpha() | 알파벳 문자 여부
* 단순 알파벳이 아닌 유니코드 상 문자 |
| s.isupper() | 대문자 여부 |
| s.islower() | 소문자 여부 |
- is는 검증 메서드 → boolean type return

> 문자열 조작 메서드(새 문자열 반환)
> 

| s.replace(old, new[, count]) | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
[, count]는 3번째 인자(선택 인자)
파이썬에서는 new로만 표현 (언어별로 다르기 때문에→ 배커스-나우르) |
| --- | --- |
| s.strip([chars]) | 공백이나 특정 문자를 제거 |
| s.split(sep=None, maxsplit=-1) | 공백이나 특정 문자를 기준으로 분리 |
| ‘ separator’.join([iterable]) | 구분자로 iterable을 합침 |
| s.capitalize() | 가장 첫 번째 글자를 대문자로 변경 |
| s.title() | 문자열 내 띄어쓰기 기준으로 단어의 첫 글자 —> 대문자
나머지 —> 소문자 |
| s.upper() | 모두 대문자로 변경 |
| s.lower() | 모두 소문자로 변경 |
| s.swapcase() | 대문자와 소문자를 서로 변경 |

> 리스트 값 추가 및 삭제 메서드
> 

| L.append(x) | 리스트 마지막에 항목 x를 추가 |
| --- | --- |
| L.extend(m) | Iterable m의 모든 항목들을 리스트 끝에 추가 (+=랑 동일) |
| L.insert(i, x) | 인덱스 i에 x 삽입 |
| L.remove(x) | 리스트 가장 첫 번째 x 제거 |
| L.pop() | 리스트 가장 오른쪽 항목 반환 후 제거 |
| L.pop(i) | 인덱스 i 항목을 반환 후 제거 |
| L.clear() | 리스트 모든 항목 삭제 |

⭐ append()와 extend()의 차이점

- append()는 인자로 받은 요소 그대로 리스트에 추가
- extend()는 iterable한 객체를 하나씩 순회하며 추가

> 리스트 탐색 및 정렬 메서드
> 

| L.index(x, start, end) | 가장 왼쪽에 있는 x의 인덱스 반환 |
| --- | --- |
| L.reverse() | 리스트를 역순으로(정렬x) |
| L.sort() | 리스트 정렬(매개변수 이용 가능) |
| L.count(x) | 항목 x의 개수 반환 |

### 복사

> **데이터 타입과 복사**
> 
- immutable / mutable로 나뉨

> **유형**
> 
- 할당
    - 해당 객체에 대한 객체 참조를 복사
- 얕은 복사
    
    ```python
    **# 슬라이싱을 통한 복사**
    a = [1, 2, 3]
    b = a[:]
    이런 경우 a 리스트의 주소 값과는 다른 주소로 b가 할당되지만, 실제 리스트 내 요소들은
    같은 주소를 참조하고 있기 때문에, a 리스트 요소의 값이 변한다면 b 리스트 요소도 변함
    -> 리스트 내 리스트를 가지고 있을 때, 내부 리스트의 주소 값은 같다는 것을 생각
    ```
    
- 깊은 복사
- deepcopy 이용